---
title: "Trabalho Simulação"
author: "Gabriel Mizuno"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

#Funções Auxiliares

```{r}
expo <- function(lambda){
  u <- runif(1)
  y <- -log(1-u)/lambda
  return(y)
}
```

```{r}
expo2 <- function(lambda,n){
  X <- 0
  for (i in 1:n){
    X[i] <- expo(lambda)
  }
  return(X)
}
```

#Sistema de Fila em Sequencia
Definindo as variaveis do problema:

SS=c(n1,n2)  
$N_A$=Número de chegada ate tempo t  
$N_D$=Número de saidas ate tempo t  
$A_1(n)$=Tempo de chegada do $n$-esimo cliente no servidor 1 (A1)  
$A_2(n)$=Tempo de chegadado $n$-esimo cliente no servidor 2 (A2)  
$D(n)$=Tempo de saida do $n$-esimo cliente do sistema (D)  
$t_a$=Tempo da proxima chegada  
$t_1$=Tempo gasto do cliente atualmente no servidor 1$\sim$Exp(1) (G1)    
$t_2$=Tempo gasto do cliente atualmente no servidor 2$\sim$Exp(3) (G2)   
$T$=Tempo de analise  
$\lambda(t)$=3+$\frac{4}{t+1}$, se $t\geq 0$

Definidas as variaveis vamos implementar o algoritmo
 q
###Implementando Subrotina para esse problema

```{r}
#Tempo de chegada de um processo poisson não homogeneo apos S

#lambda_t=lambda(t)

t_s <- function(lambda,s){
  t <- s
  u2 <- runif(1)
  lambda_t <- 3+4/(t+1)
  t <- t+expo(lambda)
  while (u2>lambda_t/lambda){
    t <- t+expo(lambda)
    u2 <- runif(1)
  }
  t_s <- t
  return(t_s)
}
```

```{r}
series_queue <- function(Time){
  t <- 0; Na <- 0; Nd <- 0; n1 <- 0; n2 <- 0; A1 <- 0; A2 <- 0; D <- 0
  ta <- t_s(7, 0) ; t1 <- Inf ; t2 <- Inf
  #browser()
  while(ta <= Time){
    # CASO 1
    if(ta == min(ta, t1, t2)){
      t <- ta
      Na <- Na + 1
      n1 <- n1 + 1
      ta <- t_s(7, t) 
      if(n1 == 1) {
        t1 <- t + expo(1)
      }
      A1[Na] <- t
    }
    # CASO 2
    if(t1 < ta & t1 <= t2){
      t <-  t1
      n1 <- n1 - 1 ; n2 <- n2 + 1
      if(n1 == 0){
        t1 <- Inf
      } 
      else {
        t1 <- t + expo(1)
      }
      if(n2 == 1) {
        t2 <- t + expo(3)
        }
      A2[Na - n1] <- t
    }
    #CASO3
    if(t2 < ta & t2 < t1){
      t <- t2
      Nd <- Nd + 1
      n2 <- n2 - 1
      if(n2 == 0) {
        t2 <- Inf
      }
      if(n2 > 0) {
        t2 <- t + expo(3)
      }
      D[Nd] <- t
    }
  }
  #Depois que fecha estou tirando as pessas da fila
  while (n1!=0 | n2!=0){
    if (t1 <= t2){
      t <-  t1
      n1 <- n1 - 1 ; n2 <- n2 + 1
      if(n1 == 0){
        t1 <- Inf
      } 
      else {
        t1 <- t + expo(1)
      }
      if(n2 == 1) {
        t2 <- t + expo(3)
      }
      A2[Na - n1] <- t
    }
    else{
      t <- t2
      Nd <- Nd + 1
      n2 <- n2 - 1
      if(n2 == 0) {
        t2 <- Inf
      }
      if(n2 > 0) {
        t2 <- t + expo(3)
      }
      D[Nd] <- t
    }
  }
  return(list(perm = mean(D - A1)))
  }
series_queue(100)

e <- 0
for(i in 1:100){
  e[i] <- mean(series_queue(100)$perm)
}
mean(e)
```


#Modelo de risco de seguro

Definindo as variaveis do problema:  

$T$="Tempo de analise"$=365$ dias  
$a_0$="capital inicial"$=25000$  
$J = \left\{
\begin{array}{lll}
\ 1 & \hbox{, se chega um novo segurando}\\
\ 2 & \hbox{, se perde um segurado}\\
\ 3 & \hbox{, se requere o seguro}
\end{array}
\right.$  
Chegada de reivindicações$\sim$Pois(10)  
Valor reivindicado$\sim$ Exp($\frac{1}{1000}$)   
  
Definidas as variavies vamos implementar o algoritmo

Simulando a quantidade de reivindicações dos segurados
```{r}
pois <- function(lambda){
  u <- runif(1)
  t <- -log(1-u)/lambda; N <- 0
  while (t<1) {
    N <- N+1; u <- runif(1)
    t <- t+(-log(1-u)/lambda)
  }
  return(N)
}
```

Vendo o ganho de um dia de operação

```{r}
ganho <- function(lambda1,lambda2){
  d <- NULL; I <- 0
  r <- pois(lambda1)
  vr <- expo2(lambda2,r)
  d[1] <- 25000+11000-sum(vr)
  
  for( i in 2:365){
    r <- pois(lambda1)
    vr <- expo2(lambda2,r)
    d[i] <- d[i-1]+11000-sum(vr)
  }
  for (i in 1:365){
    if (d[i]>0){
      I[i] <- 1
    }
    else {
      I[i] <- 0
    }
  }
  return(list(Indicadora=mean(I),Lucro=sum(d)))
}
```

Estimando a media do ganho anual

```{r}
e <- 0
for (i in 1:100){
  e[i] <- ganho(10,1/1000)$Indicadora
}
mean(e)
```


#Modelo de Reparo
Definindo as variaveis do problema: 

$t_i$ tempo de quebra da maquina    
$t$=vetor ordenado de $t_i$  
$tr$ tempo que a maquina termina o reparo  
$n$=total de maquinas em uso=4  
$s$=total de maquina na reserva=3    
$r$=número de maquinas quebradas  
$F\sim$Exp(1), $G\sim$Exp(2)   

```{r}
#Iniciando
n <- 4; s <- 3; 
reparo <- function(n,s){
  X <- expo2(1,n)
  X <- sort(X); tr <- Inf; r <- 0
  
  #Començando
  while(r<s+1){
    if (X[1]<tr){
      t <- X[1]; r <- r+1
      if (r<s+1){
        x <- expo(1); X <- sort(c(X[2:n],t+x))
      }
      if (r==1){
        tr <- t+expo(2)
      }
    }
    else{
      t <- tr; r <- r-1
      if(r>0){
        tr <- t+expo(2)
      }
      else {tr <- Inf}
    }
  }
  tc <- t
  return(tc)
}
```

Achando o tempo medio

```{r}
e <- 0
for (i in 1:100){
  e[i] <- reparo(n,s)
}
mean(e)
```

